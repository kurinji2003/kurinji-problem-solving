1   :  Factorial

public class Factorial {
    // Iterative method
    public static int factorialIterative(int n) {
        long result = 1;
        for (int i = 1; i <= n; i++) {
            result *= i;  // result = result * i
        }
        return result;
    }

    public static void main(String[] args) {
        int num = 5;
        System.out.println("Factorial (Iterative) of " + num + " = " + factorialIterative(num));
    }
}

public class Factorial {
    // Recursive method
    public static int factorialRecursive(int n) {
        if (n == 0 || n == 1) {
            return 1; // Base case
        }
        return n * factorialRecursive(n - 1); // Recursive call
    }

    public static void main(String[] args) {
        int num = 5;
        System.out.println("Factorial (Recursive) of " + num + " = " + factorialRecursive(num));
    }
}

2   :  Linear Search

public class LinearSearch {
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Return index if found
            }
        }
        return -1; // Not found
    }

    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};
        int target = 30;

        int index = linearSearch(numbers, target);

        if (index != -1) {
            System.out.println("Element found at index: " + index);
        } else {
            System.out.println("Element not found");
        }
    }
}


3   :   Binary Search
//iterative
public class BinarySearch {
    public static int binarySearch(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;

        while (low <= high) {
            int mid = low + (high - low) / 2; // avoid overflow
            if (arr[mid] == target) {
                return mid; // found
            } else if (arr[mid] < target) {
                low = mid + 1; // search right half
            } else {
                high = mid - 1; // search left half
            }
        }
        return -1; // not found
    }

    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50, 60};
        int target = 40;

        int index = binarySearch(numbers, target);
        if (index != -1) {
            System.out.println("Element found at index: " + index);
        } else {
            System.out.println("Element not found");
        }
    }
}

//recursive
public class BinarySearch {
    public static int binarySearchRecursive(int[] arr, int low, int high, int target) {
        if (low > high) {
            return -1; // Base case: not found
        }

        int mid = low + (high - low) / 2; // avoid overflow

        if (arr[mid] == target) {
            return mid; // Found
        } else if (arr[mid] < target) {
            return binarySearchRecursive(arr, mid + 1, high, target); // Search right half
        } else {
            return binarySearchRecursive(arr, low, mid - 1, target); // Search left half
        }
    }

    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50, 60};
        int target = 50;

        int index = binarySearchRecursive(numbers, 0, numbers.length - 1, target);

        if (index != -1) {
            System.out.println("Element found at index: " + index);
        } else {
            System.out.println("Element not found");
        }
    }
}

4    :   Missing number
approach 1:
public class MissingNumberTwoLoops {
    public static int findMissingNumber(int[] arr) {
        int n = arr.length + 1; // one number missing

        // Outer loop: numbers from 1 to n
        for (int i = 1; i <= n; i++) {
            boolean found = false;

            // Inner loop: check if i exists in array
            for (int j = 0; j < arr.length; j++) {
                if (arr[j] == i) {
                    found = true;
                    break; // found the number, no need to check further
                }
            }

            if (!found) {
                return i; // i is missing
            }
        }

        return -1; // should never happen if input is valid
    }

    public static void main(String[] args) {
        int[] numbers = {1, 2, 4, 5};
        System.out.println("Missing number: " + findMissingNumber(numbers));
    }
}



approach 2:
public class MissingNumberUsingFormula {
    public static int findMissingNumber(int[] arr) {
        int n = arr.length + 1; // because one number is missing
        int expectedSum = n * (n + 1) / 2;

        int actualSum = 0;
        for (int num : arr) {
            actualSum += num;
        }

        return expectedSum - actualSum;
    }

    public static void main(String[] args) {
        int[] numbers = {1, 2, 4, 5};
        System.out.println("Missing number: " + findMissingNumber(numbers));
    }
}


import java.util.Arrays;

public class MissingNumberSort {
    public static int findMissingNumber(int[] arr) {
        Arrays.sort(arr); // Step 1: Sort the array

        // Step 2: Compare each element with expected value
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != i + 1) {
                return i + 1; // Found the missing number
            }
        }

        // Step 3: If no number missing in between, last number is missing
        return arr.length + 1;
    }

    public static void main(String[] args) {
        int[] numbers = {4, 2, 1, 5};
        System.out.println("Missing number: " + findMissingNumber(numbers));
    }
}

public class MissingNumberBitwise {
    public static int findMissingNumber(int[] arr) {
        int n = arr.length + 1; // one number missing

        int xorAll = 0;
        int xorArr = 0;

        // XOR all numbers from 1 to n
        for (int i = 1; i <= n; i++) {
            xorAll ^= i;
        }

        // XOR all elements in the array
        for (int num : arr) {
            xorArr ^= num;
        }

        // Missing number is the XOR of the above results
        return xorAll ^ xorArr;
    }

    public static void main(String[] args) {
        int[] numbers = {1, 2, 4, 5};
        System.out.println("Missing number: " + findMissingNumber(numbers));
    }
}
/* a ^ a = 0
   a ^ 0 = a
Array = {1, 2, 4, 5}, n = 5

xorAll = 1 ^ 2 ^ 3 ^ 4 ^ 5

xorArr = 1 ^ 2 ^ 4 ^ 5

Missing = xorAll ^ xorArr

Cancels out all matching numbers → result = 3
Time Complexity: O(n) — single pass over range and array.

Space Complexity: O(1) — constant variables only.*/

5   :   Duplicate Number

approach 1 :hashing

import java.util.HashSet;

public class FindDuplicates {
    public static void main(String[] args) {
        int[] arr = {4, 3, 2, 7, 8, 2, 3, 1};

        HashSet<Integer> set = new HashSet<>();

        System.out.print("Duplicates: ");
        for (int num : arr) {
            if (set.contains(num)) { // already seen → duplicate
                System.out.print(num + " ");
            } else {
                set.add(num); // mark as seen
            }
        }
    }
}

approach 2: bitwise xor(only for consecutive case)
public class FindDuplicateXOR {
    public static int findDuplicate(int[] arr) {
        int n = arr.length; // array length is n, numbers are 1..n-1
        int xorArray = 0;
        int xorRange = 0;

        // XOR all elements in the array
        for (int num : arr) {
            xorArray ^= num;
        }

        // XOR all numbers from 1 to n-1
        for (int i = 1; i <= n - 1; i++) {
            xorRange ^= i;
        }

        // The result is the duplicate number
        return xorArray ^ xorRange;
    }

    public static void main(String[] args) {
        int[] numbers = {1, 3, 4, 2, 5, 3}; // duplicate is 3
        System.out.println("Duplicate number: " + findDuplicate(numbers));
    }
}
/*Array = {1, 3, 4, 2, 5, 3}, n=6

xorArray = 1 ^ 3 ^ 4 ^ 2 ^ 5 ^ 3 → cancels out matching numbers, leaves 1 ^ 4 ^ 2 ^ 5 plus an extra 3.

xorRange = 1 ^ 2 ^ 3 ^ 4 ^ 5 → contains exactly one copy of each expected number.

xorArray ^ xorRange cancels everything except the duplicate → 3 */



6  :   Get,Set,Clear

public class BitwiseOperations {

    // Get bit (returns 0 or 1)
    static int getBit(int num, int pos) {
        return (num >> pos) & 1;
    }

    // Set bit 
    static int setBit(int num, int pos) {
        return num | (1 << pos);
    }

    // Clear bit 
    static int clearBit(int num, int pos) {
        return num & ~(1 << pos);
    }

    public static void main(String[] args) {
        int num = 5;   // binary: 0101
        int pos = 1;   // bit position (0-indexed from right)

        // Original
        System.out.println("Original number: " + num + " (" + Integer.toBinaryString(num) + ")");

        // Get bit
        int bitValue = getBit(num, pos);
        System.out.println(bitValue);

        // Set bit
        int numAfterSet = setBit(num, pos);
        System.out.println("After setting bit " + pos + ": " + numAfterSet + " (Integer.toBinaryString(numAfterSet));

        // Clear bit
        int numAfterClear = clearBit(num, pos);
        System.out.println(Integer.toBinaryString(numAfterClear));
    }
}
/*Original number: 5 (101)
Bit at position 1: 0
After setting bit 1: 7 (111)
After clearing bit 1: 5 (101)*/
