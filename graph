Graph
  TRAVERSAL(BFS ,  DFS)

DFS Traversal
import java.util.*;

class DFSTraversal {
    // Recursive DFS function
    static void dfs(int node, boolean[] visited, List<List<Integer>> adj, List<Integer> result) {
        visited[node] = true;          // mark as visited
        result.add(node);              // add to traversal list

        for (int neighbor : adj.get(node)) {
            if (!visited[neighbor]) {
                dfs(neighbor, visited, adj, result);
            }
        }
    }

    static List<Integer> dfsOfGraph(int V, List<List<Integer>> adj) {
        boolean[] visited = new boolean[V];
        List<Integer> result = new ArrayList<>();

        // Run DFS for all unvisited nodes (for disconnected graphs)
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                dfs(i, visited, adj, result);
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int V = 5;
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());

        // Build graph
        adj.get(0).add(1);
        adj.get(0).add(2);
        adj.get(1).add(0);
        adj.get(1).add(3);
        adj.get(2).add(0);
        adj.get(2).add(4);
        adj.get(3).add(1);
        adj.get(3).add(4);
        adj.get(4).add(2);
        adj.get(4).add(3);

        List<Integer> traversal = dfsOfGraph(V, adj);
        System.out.println("DFS Traversal: " + traversal);
    }
}

BFS Traversal

import java.util.*;

class BFSTraversal {
    static List<Integer> bfsOfGraph(int V, List<List<Integer>> adj) {
        boolean[] visited = new boolean[V];
        List<Integer> result = new ArrayList<>();
        Queue<Integer> q = new LinkedList<>();

        // Start from node 0 (you can start anywhere)
        visited[0] = true;
        q.add(0);

        while (!q.isEmpty()) {
            int node = q.poll();     // remove front element
            result.add(node);        // add to traversal order

            for (int neighbor : adj.get(node)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.add(neighbor);
                }
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int V = 5;
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());

        // Build the undirected graph
        adj.get(0).add(1);
        adj.get(0).add(2);
        adj.get(1).add(0);
        adj.get(1).add(3);
        adj.get(2).add(0);
        adj.get(2).add(4);
        adj.get(3).add(1);
        adj.get(3).add(4);
        adj.get(4).add(2);
        adj.get(4).add(3);

        System.out.println("BFS Traversal: " + bfsOfGraph(V, adj));
    }
}

Cycle Detection in Undirected Graph
Start DFS from each unvisited node

(because the graph may be disconnected)

2️⃣ For each node:

Mark it as visited.

For each neighbor:

If neighbor is not visited, recursively DFS on it.

If neighbor is visited and not the parent, then → cycle exists.

import java.util.*;

class DetectCycle {
    public static boolean isCycle(int V, List<List<Integer>> adj) {
        boolean[] visited = new boolean[V];

        // handle disconnected graphs
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                if (dfs(i, -1, visited, adj))
                    return true; // cycle found
            }
        }
        return false; // no cycle
    }

    private static boolean dfs(int node, int parent, boolean[] visited, List<List<Integer>> adj) {
        visited[node] = true;

        for (int neighbor : adj.get(node)) {
            if (!visited[neighbor]) {
                if (dfs(neighbor, node, visited, adj))
                    return true;
            } 
            else if (neighbor != parent) {
                // visited but not parent → cycle
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        int V = 3;
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());

        adj.get(0).add(1);
        adj.get(1).add(0);
        adj.get(1).add(2);
        adj.get(2).add(1);
        adj.get(2).add(0);
        adj.get(0).add(2);

        System.out.println("Cycle present: " + isCycle(V, adj));
    }
}

Cycle detection in directed graph

import java.util.*;

class DirectedGraphCycle {

    static boolean isCyclic(int V, List<List<Integer>> adj) {
        boolean[] visited = new boolean[V];
        boolean[] recStack = new boolean[V];

        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                if (dfs(i, visited, recStack, adj))
                    return true;
            }
        }
        return false;
    }

    private static boolean dfs(int node, boolean[] visited, boolean[] recStack, List<List<Integer>> adj) {
        visited[node] = true;
        recStack[node] = true;

        for (int neighbor : adj.get(node)) {
            if (!visited[neighbor]) {
                if (dfs(neighbor, visited, recStack, adj)) return true;
            } else if (recStack[neighbor]) {
                // Node is in current DFS path → cycle
                return true;
            }
        }

        recStack[node] = false; // remove node from current path
        return false;
    }

    public static void main(String[] args) {
        int V = 3;
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());

        adj.get(0).add(1);
        adj.get(1).add(2);
        adj.get(2).add(1); // cycle here

        boolean hasCycle = isCyclic(V, adj);
        System.out.println("Cycle present: " + hasCycle);
    }
}

Topological sorting (kahns algo)-> BFS

Find nodes with no dependencies (no incoming edges).

Pick one and place it in the ordering.

Remove it from the graph → decrease indegrees of its neighbors.

Repeat until all nodes are placed.

If multiple nodes have indegree 0, any order among them is valid → multiple topological sorts exist.


import java.util.*;

class TopologicalSortBFS {

    static List<Integer> topologicalSort(int V, List<List<Integer>> adj) {
        int[] indegree = new int[V];
        List<Integer> result = new ArrayList<>();

        // Step 1: Compute indegree of each node
        for (int u = 0; u < V; u++) {
            for (int v : adj.get(u)) {
                indegree[v]++;
            }
        }

        // Step 2: Initialize queue with nodes of indegree 0
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < V; i++) {
            if (indegree[i] == 0) q.add(i);
        }

        // Step 3: Process nodes
        while (!q.isEmpty()) {
            int node = q.poll();
            result.add(node);

            for (int neighbor : adj.get(node)) {
                indegree[neighbor]--;
                if (indegree[neighbor] == 0) q.add(neighbor);
            }
        }

        // Optional: check if graph had a cycle
        if (result.size() != V) {
            System.out.println("Graph has a cycle! Topological sort not possible.");
        }

        return result;
    }

    public static void main(String[] args) {
        int V = 6; // nodes 0..5
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());

        // Example graph
        adj.get(5).add(2);
        adj.get(5).add(0);
        adj.get(4).add(0);
        adj.get(4).add(1);
        adj.get(2).add(3);
        adj.get(3).add(1);

        List<Integer> topoOrder = topologicalSort(V, adj);
        System.out.println("Topological Sort: " + topoOrder);
    }
}

TOPO SORT using DFS

import java.util.*;

class TopologicalSortDFS {

    // Recursive DFS helper
    static void dfs(int node, boolean[] visited, Stack<Integer> stack, List<List<Integer>> adj) {
        visited[node] = true;

        for (int neighbor : adj.get(node)) {
            if (!visited[neighbor]) {
                dfs(neighbor, visited, stack, adj);
            }
        }

        // Push node to stack after all neighbors are visited
        stack.push(node);
    }

    // Main topological sort function
    static List<Integer> topologicalSort(int V, List<List<Integer>> adj) {
        boolean[] visited = new boolean[V];
        Stack<Integer> stack = new Stack<>();
        List<Integer> result = new ArrayList<>();

        // Call DFS for all unvisited nodes
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                dfs(i, visited, stack, adj);
            }
        }

        // Pop all nodes from stack to get topological order
        while (!stack.isEmpty()) {
            result.add(stack.pop());
        }

        return result;
    }

    public static void main(String[] args) {
        int V = 6; // Number of nodes 0..5
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) adj.add(new ArrayList<>());

        // Example graph
        adj.get(5).add(2);
        adj.get(5).add(0);
        adj.get(4).add(0);
        adj.get(4).add(1);
        adj.get(2).add(3);
        adj.get(3).add(1);

ROTTEN ORANGES

import java.util.*;

class Solution {
    // Custom class to store a cell's coordinates
    static class Cell {
        int row, col;
        Cell(int row, int col) {
            this.row = row;
            this.col = col;
        }
    }

    public int orangesRotting(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        
        Queue<Cell> q = new LinkedList<>();
        int fresh = 0;
        
        // Step 1: Add all rotten oranges into the queue
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 2) {
                    q.offer(new Cell(i, j));  // rotten orange
                } else if (grid[i][j] == 1) {
                    fresh++;  // count fresh oranges
                }
            }
        }

        // If there are no fresh oranges initially
        if (fresh == 0) return 0;

        // Step 2: Directions - up, down, left, right
        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        int minutes = -1;

        // Step 3: BFS
        while (!q.isEmpty()) {
            int size = q.size();
            minutes++;

            for (int i = 0; i < size; i++) {
                Cell cur = q.poll();

                for (int[] d : dirs) {
                    int nr = cur.row + d[0];
                    int nc = cur.col + d[1];

                    // Check if the neighbor is inside the grid and fresh
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1) {
                        grid[nr][nc] = 2;  // make it rotten
                        q.offer(new Cell(nr, nc));  // add new rotten cell
                        fresh--;
                    }
                }
            }
        }

        // Step 4: If any fresh orange remains, it's impossible
        if (fresh > 0) return -1;
        return minutes;
    }
}
COURSE SCHEDULE

import java.util.*;

class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        // Step 1: Create adjacency list
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) adj.add(new ArrayList<>());

        int[] indegree = new int[numCourses];

        // Step 2: Fill adjacency list and indegree array
        for (int[] pre : prerequisites) {
            int course = pre[0];
            int prereq = pre[1];
            adj.get(prereq).add(course);
            indegree[course]++;
        }

        // Step 3: Push all nodes with indegree 0 to queue
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) q.offer(i);
        }

        int count = 0; // number of courses that can be completed

        // Step 4: BFS (Topological sort)
        while (!q.isEmpty()) {
            int curr = q.poll();
            count++;

            for (int next : adj.get(curr)) {
                indegree[next]--;
                if (indegree[next] == 0) {
                    q.offer(next);
                }
            }
        }

        // Step 5: If all courses processed → no cycle → return true
        return count == numCourses;
    }
}


        List<Integer> topoOrder = topologicalSort(V, adj);
        System.out.println("Topological Sort (DFS): " + topoOrder);
    }
}
Number of islands(DFS)

class Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;

        int rows = grid.length;
        int cols = grid[0].length;
        int count = 0;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // When we find land
                if (grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }

    private void dfs(char[][] grid, int r, int c) {
        // Boundary or water check
        if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] != '1') {
            return;
        }

        // Mark visited land as '0' (water)
        grid[r][c] = '0';

        // Visit all 4 directions
        dfs(grid, r + 1, c);
        dfs(grid, r - 1, c);
        dfs(grid, r, c + 1);
        dfs(grid, r, c - 1);
    }
}
Number of islands(BFS)

import java.util.*;

class Solution {
    // Custom class to represent a cell's coordinates
    static class Cell {
        int row, col;
        Cell(int row, int col) {
            this.row = row;
            this.col = col;
        }
    }

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;

        int rows = grid.length;
        int cols = grid[0].length;
        int count = 0;

        // 4 possible directions → up, down, left, right
        int[][] dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};

        // Step 1: Traverse every cell
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // When we find land ('1')
                if (grid[i][j] == '1') {
                    count++;  // new island found
                    grid[i][j] = '0';  // mark visited
                    bfs(grid, i, j, dirs);
                }
            }
        }

        return count;
    }

    // Step 2: BFS traversal to mark connected lands
    private void bfs(char[][] grid, int i, int j, int[][] dirs) {
        int rows = grid.length, cols = grid[0].length;
        Queue<Cell> q = new LinkedList<>();
        q.offer(new Cell(i, j));

        while (!q.isEmpty()) {
            Cell curr = q.poll();

            // Explore 4 directions
            for (int[] d : dirs) {
                int nr = curr.row + d[0];
                int nc = curr.col + d[1];

                // Check if valid and is land
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == '1') {
                    grid[nr][nc] = '0';  // mark as visited
                    q.offer(new Cell(nr, nc));
                }
            }
        }
    }
}
